# 分かりやすい合意アルゴリズムを求めて

##概要

1. 紹介

ラフトはログの複製を管理するための合意アルゴリズムです。

	* 強いリーダー
	* リーダー選挙
	* メンバー変更

2. ステートマシンの複製

3. パクソスの何が悪いのか

4. 理解性のためのデザイン

5. ラフト合意アルゴリズム

ラフトは2章で示した形の複製ログを管理するためのアルゴリズムです。図2は、参考用にアルゴリズムを凝縮してまとめたもので、図3はアルゴリズムの重要な特性の一覧です。これらの図の要素については、このセクションの残りの部分では個別に説明します。

ラフトは最初に特別な *リーダー* を選出し、複製ログの管理に対する完全な責任を与えることで合意を行います。

リーダーはクライアントからのログエントリを受け付け、それを他のサーバー群に複製し、サーバ群の各々が持つステートマシンにログエントリを適用することが安全になったら サーバ群へ通知を行います。リーダーを持つことは複製ログの管理を単純化します。例えば、リーダーは他のサーバ群と相談せずに ログのどこに新しいエントリを置くかを決定でき、データはリーダーから他のサーバ群へ単純な方法で受け渡されます。 リーダーは障害が起こったり、他のサーバ群から切断されることがありますが、そのときは新たなリーダーが選ばれます。

リーダーアプローチによってラフトは合意問題を後の節で説明する3つの比較的独立した部分問題に分解します。

  * リーダー選挙 : 新たなリーダは既存のリーダが障害となったときに選ばれる必要があります。(5.2章)

  * ログ複製 : リーダーはクライアントからログエントリーを受け付け、それをクラスタ全体に複製し、自身と他のログとを強制的に一致させる必要があります。(5.3章)

  * 安全性 : 

--------
# 状態

## 全サーバーの永続的状態 :
(RPCに応答する前に安定したストレージ上で更新される)

currentTerm	サーバーが見る 最新の期間 (最初の起動時に 0 で初期化され、単調増加する)

votedFor	現在の期間で投票を受信した候補者ID (誰もいなければ null)

log[]   	ログエントリー。各エントリーはステートマシンに対するコマンドを含んでおり、リーダーによってエントリーが受信されたら終了する (最初のインデックスは 1)


## 全サーバの揮発的状態 :
commitIndex	コミットされたログエントリーのインデックスの最大値 (0で初期化され、単調増加する)

lastApplied	ステートマシンに適用されたログエントリーの最大のインデックス (0で初期化され、単調増加する)


## リーダーの揮発的状態 :
(選挙後に再初期化される)

nextIndex[]	各サーバーに送信される次のログエントリーのインデックス (リーダーの最新のログインデックス +1 に初期化される)

matchIndex[]	各サーバーが複製されたと認識するログエントリーの最大のインデックス (0で初期化され、単調増加する)


--------
# エントリー追加 RPC
ログエントリーを複製するためにリーダーが実行する(5.3節) またハートビートにも使用される。

## 引数

term    	リーダーの期間番号

leaderId	フォロワーがクライアントをリダイレクトするために使う

prevLogIndex	新しいログエントリーに先行するログエントリーのインデックス

prevLogTerm	prevLogindex エントリーの期間番号

entries[]	保存するログエントリー(ハートビートの時は空。有効性のために1回以上の送信があってよい)

leaderCommit	リーダーの commitIndex

## 結果

term	リーダーが自身を更新するための currentTerm

success	フォロワーが prevLogIndex と prevLogTerm にマッチするエントリーを保存した場合 true となる

## 受信側の実装
1. term < currentTerm なら false を返信する (5.1節)
2. ログが「term が prevLogTerm と等しい、prevLogIndex 番目のエントリ」を持たないとき false を返信する (5.3節)
3. 既存エントリーが新しいものとコンフリクトする(インデックスが同じだが term が異なる)なら、既存のエントリーとそれに続く全てのエントリーを削除する。
4. ログに無い 新たなエントリーは いかなるものでも 追加する
5. leaderCommit > commitIndex なら、commitIndex = min( leaderCommit, 最後の新エントリーのインデックス)

--------
# 投票依頼 RPC
投票を集めるために候補者によって呼び出される

## 引数

term    	候補者の期間番号

cadidateId	投票を要求する候補者

lastLogIndex	候補者の最後のログエントリーのインデックス(5.4節)

lastLogTerm	候補者の最後のログエントリーの期間番号(5.4節)

## 結果

term		候補者が currentTerm をこれで更新する

voteGranted	true は候補者が投票を受信したことを意味する。

## 受信側の実装
1. term < currentTerm なら false を返信する。(5.1節)
2. votedFor が null 若しくは candidateId、かつ、候補者のログが少なくとも受信者のログと同等に最新なら、投票権を付与する。(5.2, 5.4節)

--------
# サーバーの規則

## 全てのサーバー
* commitIndex > lastApplied なら lastApplied をインクリメントし、ステートマシンに log[lastApplied] を適用する。

* RPC要求または応答が currentTerm より大きい 期間番号T を持つ (T > currentTerm) なら currentTerm に T をセットして、フォロワーになる。 (5.1節)

## フォロワー (5.2節)
* 候補者とリーダーからのRPCに応答する
* 現在のリーダーからの AppendEntries RPC の受信、あるいは、候補者投票権の付与を受信せずに選挙タイムアウトが経過したら、候補者になる。

## 候補者 (5.2節)
* 候補者との会話では、選挙を始めるとき
  * currentTerm をインクリメントする
  * 自身に投票する
  * 選挙タイマーをリセットする
  * 投票依頼 RPC を全ての他のサーバへ送信する
* サーバーの多数派から投票を受信したらリーダーになる
* 新たなリーダーから エントリー追加 RPC を受信したらフォロワーになる
* 選挙タイムアウトが経過したら新たな選挙を始める

## リーダー
* 選挙後、最初に空の エントリー追加 RPC (ハートビート) を各サーバーへ送信する。選挙タイムアウトを防ぐために、休眠期間毎に継続する。
* クライアントからコマンドを受信したら、ローカルログにエントリーを追加して、ステートマシンにエントリーを適用後、返信する。(5.3節)
* 「最後の ログのインデックス」 > 「フォロワーに対する nextIndex」ならエントリー追加 RPC をnextIndex で始まる ログエントリーと一緒に送る。
  * 成功したら、フォロワーに対する nextIndex と matchindex を更新する(5.3節)
  * ログに一貫性が無く エントリー追加 が失敗したら、nextIndex をデクリメントしてリトライする(5.3節)
* N > commitIndex , 「matchIndex[i] の多数派」≧ N , かつ, log[N].term == currentTerm となるような N が存在するなら、 commitIndex に N をセットする (5.3節、5.4節)

--------
図2 : ラフト コンセンサスアルゴリズムの要約 (メンバーシップ変更とログ圧縮を除く)  
「状態」に書かれている動作は、独立かつ反復して適用されるルールの集合として記述されている。
5.2節のような節番号は特定の機能が議論されている場所を示している。
形式仕様 [[31] はより正確なアルゴリズムについて説明しています。

--------

5.1 ラフトの基本

5.2 リーダー選挙

5.3 ログ複製

5.4 安全性

前節ではRaftがリーダーを選出し、ログエントリーを複製する方法を述べた。しかし、これまでに述べたメカニズムでは、各ステートマシンが正確に同じコマンドを同じ順序で実行することを保障できない。例えば、フォロワーはリーダーがいくつかのログエントリーをコミットする間、止まっているかもしれず、そのような状況でリーダーが選出され、それらエントリーが新しいもので上書きされうる。その結果、異なるステートマシンが異なるコマンド列を実行するかもしれない。

この節では、リーダーに選出されることが許されるサーバを制限することでRaftアルゴリズムを完成させる。 この制限は、任意の任期のリーダーがそれ以前の任期におけるコミットの全エントリを持っていることを保証する。(図3 の Leader Completeness 属性を参照） 選挙に制約を与え、約束(コミットメント)のためのルールをより正確にする。最後に、リーダーの完全性属性に対する証明の絵を示し、それが複製されたステートマシンの正しい振る舞いを導出する方法を示す。

5.4.1 選挙制約

リーダーベースのアルゴリズムでは、リーダーは最終的に全てのコミットされたログエントリを保存しなければならない。
Viewstamped Replication [22] のような いくつかの合意アルゴリズムでは、リーダーは それがコミットされた全てのエントリを初期に持たなくても選出されうる。これらのアルゴリズムは選挙プロセスの間か、その後の短期間に、新しいリーダーへ彼がまだ持っていないエントリを識別し、転送する追加的な仕組みを持つ。残念ながら、これはかなりの追加的な仕組みと複雑さをもたらす。Raftは、前の期間の全てのコミットされたエントリを、選挙の瞬間から、それらエントリをリーダーへ転送すること無く、新しいリーダが持つ より単純なアプローチを用いる。これはログエントリがリーダーからフォロワーへの一方向へのみ流れ、リーダーはログの中の既存エントリを決して上書きしないことを意味する。

 Raftはログにコミットされた全エントリが格納されるまで候補者が選挙に勝たないようにするために投票プロセスを用いる。候補者は選ばれるためにクラスタの多数派とコンタクトしなければならず、これはコミットされた各エントリがそれらサーバ群のの少なくとも1つに存在しなければならないことを意味する。
 もし候補者のログが少なくとも多数派の他のログと同等に最新なら、それはコミットされた全エントリを持つだろう。(「最新」の意味は後で正確に定義する) RequestVote RPC はこの制限を実装する、即ち そのRPCは候補者の持つログについての情報を含み、投票者は彼自身の持つログが候補者のものより新しいなら投票を拒否する。
 
 Raftは2つのログの何れがより新しいかを、ログ内の最新エントリの index と term  とを比較することによって、決定する。
 もし複数のログが term の異なる最新エントリを持つ場合、より後の term のログがより最新のものになる。もし複数のログが同じ term で終わっているなら、より長いログが最新である。

5.4.2 前期間のエントリをコミットする

 5.3節で述べた通り、リーダーが現在期間の あるエントリのコミットを知るのは、
サーバ群の多数派にそれが保存された後である。もしエントリのコミット前にリーダーがクラッシュしたら、将来のリーダーはそのエントリの複製処理を完了しようとする。しかし、リーダーは前期間のあるエントリがサーバ群の多数派に保存されたことを直ぐには結論できない。

 Figure 8 は古いログエントリがサーバ群の多数派に格納され、将来のリーダによって上書きされうる状況を描いている。

 Figure 8 にあるような問題を取り除くため、Raft は、複製を数えることによって、前期間のログエントリを決してコミットしない。

5.4.3 安全性引数

5.5 フォロワーと候補者のクラッシュ

5.6 タイミングと可用性

6 クラスタメンバーシップの変更

7 ログの圧縮

8 クライアントとの対話

9 実装と評価

9.1 理解性

9.2 正確性

9.3 性能

10 関連する研究

11 結論

12 謝辞

## 参照
